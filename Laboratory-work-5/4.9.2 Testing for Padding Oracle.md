# Зведення

Оракул заповнення — це функція програми, яка розшифровує зашифровані дані, надані клієнтом, напр. стан внутрішнього сеансу, що зберігається на клієнті, і витікає стан дійсності доповнення після дешифрування. Існування оракула заповнення дозволяє зловмиснику розшифровувати зашифровані дані та шифрувати довільні дані без знання ключа, який використовується для цих криптографічних операцій. Це може призвести до витоку конфіденційних даних або до вразливості підвищення привілеїв, якщо програма передбачає цілісність зашифрованих даних.

Блокові шифри шифрують дані лише блоками певного розміру. Розміри блоків, які використовуються звичайними шифрами, становлять 8 і 16 байт. Дані, розмір яких не відповідає кратному розміру блоку використаного шифру, мають бути доповнені певним чином, щоб дешифратор міг видалити доповнення. Часто використовуваною схемою доповнення є PKCS#7. Він заповнює решту байтів значенням довжини доповнення.

#### Приклад 1

Якщо заповнення має довжину 5 байтів, значення байта 0x05 повторюється п’ять разів після звичайного тексту.

Помилка наявна, якщо заповнення не відповідає синтаксису використаної схеми заповнення. Оракул заповнення присутній, якщо програма витікає з цієї конкретної умови помилки заповнення для зашифрованих даних, наданих клієнтом. Це може статися через пряме виявлення винятків (наприклад, BadPaddingException у Java), через тонкі відмінності у відповідях, надісланих клієнту, або через інший бічний канал, як-от поведінка синхронізації.

Певні режими роботи криптографії допускають атаки з перевертанням біта, коли перевертання біта в зашифрованому тексті призводить до того, що біт також перевертається у відкритому тексті. Перевертання біта в n-му блоці зашифрованих даних CBC призводить до того, що той самий біт у (n+1)-му блоці перевертається в розшифрованих даних. n-й блок розшифрованого шифрованого тексту смітить цією маніпуляцією.

Атака за допомогою оракула заповнення дає змогу зловмиснику розшифрувати зашифровані дані, не знаючи ключа шифрування та використаного шифру, надсилаючи вміло оброблені тексти шифру до оракула заповнення та спостерігаючи за результатами, які він повертає. Це призводить до втрати конфіденційності зашифрованих даних. наприклад у випадку даних сесії, що зберігаються на стороні клієнта, зловмисник може отримати інформацію про внутрішній стан і структуру програми.

Атака оракула заповнення також дозволяє зловмиснику шифрувати довільні прості тексти, не знаючи використаного ключа та шифру. Якщо програма припускає, що цілісність і автентичність розшифрованих даних надано, зловмисник зможе маніпулювати станом внутрішнього сеансу та, можливо, отримати вищі привілеї.

## Мета тестування

- Визначити зашифровані повідомлення, які покладаються на заповнення.
- Спробуйте зламати заповнення зашифрованих повідомлень і проаналізуйте повернуті повідомлення про помилки для подальшого аналізу.

### Як провести тестування

#### Тестування чорної скриньки

Спочатку необхідно визначити можливі точки введення для оракулів заповнення. Загалом мають бути виконані такі умови:

1. Дані зашифровані. Хороші кандидати - це значення, які здаються випадковими.
2. Використовується блоковий шифр. Довжина декодованого (часто використовується Base64) шифрованого тексту є кратною величиною звичайних розмірів блоку шифру, наприклад 8 або 16 байт. Різні шифровані тексти (наприклад, зібрані різними сеансами або маніпулюванням станом сеансу) мають спільний дільник довжини.

#### Приклад 2

Dg6W8OiWMIdVokIDH15T/A== результати після декодування Base64 у 0e 0e 96 f0 e8 96 30 87 55 a2 42 03 1f 5e 53 fc. Це здається випадковим і має довжину 16 байт.

Якщо такий кандидат на вхідне значення ідентифіковано, слід перевірити поведінку програми щодо побітового втручання в зашифроване значення. Зазвичай це значення, закодоване Base64, включатиме вектор ініціалізації (IV), доданий до зашифрованого тексту. Дано відкритий текст p і шифр із розміром блоку n, кількість блоків буде b = ceil( length(b) / n). Довжина зашифрованого рядка буде y=(b+1)*n через вектор ініціалізації. Щоб перевірити присутність оракула, декодуйте рядок, переверніть останній біт передостаннього блоку b-1 (молодший біт байта в y-n-1), повторно закодуйте та надішліть. Далі декодуйте вихідний рядок, переверніть останній біт блоку b-2 (молодший біт байта в y-2*n-1), повторно закодуйте та надішліть.

Якщо відомо, що зашифрований рядок є одним блоком (IV зберігається на сервері або програма використовує жорстко закодований IV), необхідно виконати кілька перевертань бітів по черзі. Альтернативним підходом може бути додавання перед випадковим блоком і перевертання бітів, щоб останній байт доданого блоку приймав усі можливі значення (від 0 до 255).

Тести та базове значення повинні призвести до принаймні трьох різних станів під час і після розшифровки:

- Зашифрований текст розшифровується, отримані дані правильні.
- Зашифрований текст розшифровується, отримані дані спотворені та спричиняють деякі винятки або помилки обробки в логіці програми.
- Дешифрування зашифрованого тексту не вдається через помилки заповнення.

Уважно порівняйте відповіді. Особливо шукайте винятки та повідомлення, які стверджують, що щось не так із заповненням. Якщо такі повідомлення з’являються, програма містить оракул доповнення. Якщо три різні стани, описані вище, спостерігаються неявно (різні повідомлення про помилки, синхронізація побічних каналів), існує висока ймовірність того, що в цій точці присутній оракул заповнення. Спробуйте виконати атаку оракула заповнення, щоб переконатися в цьому.

#### Приклад 3

- ASP.NET викидає System.Security.Cryptography.CryptographicException: заповнення недійсне, і його неможливо видалити. якщо заповнення розшифрованого шифрованого тексту порушено.
- У Java в цьому випадку виникає виняткова ситуація javax.crypto.BadPaddingException.
- Помилки дешифрування або подібні можуть бути можливими оракулами доповнення.

<i>Захищена реалізація перевірить цілісність і викличе лише дві відповіді: добре та невдало. Немає бічних каналів, які можна використовувати для визначення внутрішніх станів помилок.</i>

#### Тестування сірого ящика

Переконайтеся, що всі місця, де зашифровані дані від клієнта, які мають бути відомі лише серверу, розшифровані. Такий код повинен відповідати таким умовам:

1. Цілісність зашифрованого тексту має перевірятися безпечним механізмом, наприклад HMAC, або режимами роботи шифру з автентифікацією, такими як GCM або CCM.
2. Усі стани помилок під час дешифрування та подальшої обробки обробляються однаково.
